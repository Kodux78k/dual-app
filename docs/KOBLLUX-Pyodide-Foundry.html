<!doctype html>
<html lang="pt-br">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>KOBLLUX – Pyodide Foundry (Single HTML)</title>
<meta name="theme-color" content="#0a0a0a">
<style>
:root{--c1:#00d0ff;--bg:#0a0a0a;--fg:#eaeaea;--mut:#a0a0a8}
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,'Segoe UI',Roboto,Ubuntu,'Helvetica Neue',Arial}
.container{max-width:880px;margin:0 auto;padding:20px}
.card{background:#111214;border:1px solid #22252a;border-radius:16px;padding:18px}
h1{font-size:20px;margin:0 0 8px}
p{margin:8px 0;color:var(--mut)}
.btn{appearance:none;border:0;border-radius:999px;padding:10px 16px;background:var(--c1);color:#002029;font-weight:800;cursor:pointer}
.btn.ghost{background:transparent;color:var(--fg);border:1px solid #2a2f36}
.row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
.status{font-family:ui-monospace,Menlo,Consolas,monospace;background:#0f1113;border:1px solid #1e2126;border-radius:12px;padding:10px;height:140px;overflow:auto;font-size:12px}
.drop{border:1px dashed #2a2f36;border-radius:12px;padding:16px;text-align:center}
small.tip{color:#8ea0ad}
.kx{color:#1c66b3;font-weight:800;letter-spacing:.04em}
hr{border:none;border-top:1px solid #21242a;margin:16px 0}
.badge{padding:3px 8px;border-radius:8px;border:1px solid #2a2f36;font-size:12px;color:#c8d4db}
</style>
</head>
<body>
<div class="container">
  <div class="card">
    <h1><span class="kx">KOBLLUX</span> — Pyodide Foundry</h1>
    <p>Forje sua fonte <b>KOBLLUX Symbols</b> <i>(TTF/WOFF2)</i> a partir de <code>SVGs</code> — direto no iPhone. <span class="badge">single-file</span></p>
    <div class="drop" id="drop">
      <input id="file" type="file" accept=".zip,.svg" multiple style="display:none">
      <button class="btn" id="pick">Selecionar SVGs ou ZIP</button>
      <button class="btn ghost" id="run" disabled>Forjar fonte</button>
      <div style="margin-top:8px"><small class="tip">Primeira execução baixa o runtime <b>Pyodide</b> e pacotes (~15–25MB). Após isso, o navegador tende a cachear (modo offline).</small></div>
    </div>
    <hr>
    <div class="row">
      <div id="filesInfo" class="badge">0 arquivos</div>
      <div id="pyInfo" class="badge">Pyodide: aguardando…</div>
      <div id="ftInfo" class="badge">fonttools: aguardando…</div>
    </div>
    <pre class="status" id="log"></pre>
  </div>
</div>

<script>
const logEl = document.getElementById('log');
function logln(s){ logEl.textContent += s + '\n'; logEl.scrollTop = logEl.scrollHeight; }
function setBadge(id, text){ document.getElementById(id).textContent = text; }
</script>

<!-- Pyodide loader -->
<script>
let pyodideReady = null;
async function loadPyodideAndPackages(){
  if (pyodideReady) return pyodideReady;
  setBadge('pyInfo','Pyodide: baixando…');
  const pyodide = await loadPyodide({indexURL: 'https://cdn.jsdelivr.net/pyodide/v0.25.1/full/'});
  setBadge('pyInfo','Pyodide: ok');
  logln('Pyodide carregado.');
  logln('Instalando pacotes: fonttools, picosvg, brotli, zipp…');
  setBadge('ftInfo','fonttools: instalando…');
  await pyodide.runPythonAsync(`
import micropip
await micropip.install(['fonttools','picosvg','brotli','zipp'])
print('Pacotes instalados.')
  `);
  setBadge('ftInfo','fonttools: ok');
  logln('Pacotes instalados.');
  pyodideReady = pyodide;
  return pyodide;
}
</script>
<script src="https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.js"></script>

<script>
const pickBtn = document.getElementById('pick');
const runBtn  = document.getElementById('run');
const fileInput = document.getElementById('file');
let selectedFiles = [];

pickBtn.addEventListener('click', ()=> fileInput.click());
fileInput.addEventListener('change', ()=>{
  selectedFiles = Array.from(fileInput.files || []);
  document.getElementById('filesInfo').textContent = selectedFiles.length + ' arquivos';
  runBtn.disabled = selectedFiles.length === 0;
});

async function readFileAsUint8Array(file){
  return new Uint8Array(await file.arrayBuffer());
}

async function prepareFS(pyodide){
  // mount /data in the Pyodide FS and write inputs
  const FS = pyodide.FS;
  try { FS.mkdir('/data'); } catch(e){}
  // clear old
  try {
    FS.unmount('/data');
    FS.mkdir('/data');
  } catch(e){}
  // write files
  for (const f of selectedFiles){
    const bytes = await readFileAsUint8Array(f);
    if (f.name.toLowerCase().endsWith('.zip')){
      // write zip and mark to unzip in Python
      FS.writeFile(`/data/${f.name}`, bytes);
    } else if (f.name.toLowerCase().endsWith('.svg')) {
      // put SVG into /data/svgs/
      try { FS.mkdir('/data/svgs'); } catch(e){}
      FS.writeFile(`/data/svgs/${f.name}`, bytes);
    }
  }
}

runBtn.addEventListener('click', async ()=>{
  runBtn.disabled = true;
  try{
    const pyodide = await loadPyodideAndPackages();
    await prepareFS(pyodide);
    logln('Arquivos copiados para /data.');
    const code = `
import os, io, zipfile, sys
from fontTools.fontBuilder import FontBuilder
from fontTools.ttLib import TTFont, newTable
from fontTools.pens.ttGlyphPen import TTGlyphPen
from picosvg.svg_path import parse_path
from picosvg.geometric_types import Point
import re

# helper: read svgs from /data or unzip any zips found there
svg_root = "/data/svgs"
if not os.path.isdir(svg_root):
    os.mkdir(svg_root)

for name in os.listdir("/data"):
    if name.lower().endswith(".zip"):
        with zipfile.ZipFile(os.path.join("/data", name), "r") as z:
            z.extractall("/data")
        # try to find 'svgs/' inside zip
        if os.path.isdir("/data/svgs"):
            pass
        else:
            # move any *.svg to /data/svgs
            for root,_,files in os.walk("/data"):
                for fn in files:
                    if fn.lower().endswith(".svg"):
                        src = os.path.join(root, fn)
                        dst = os.path.join(svg_root, fn)
                        if src != dst:
                            try:
                                os.rename(src, dst)
                            except:
                                pass

# collect mapping for A..Z and 0..9
def name_for(ch):
    if ch.isalpha(): return f"{ch.upper()}.svg"
    return f"{ch}.svg"

wanted = [chr(c) for c in range(ord('A'),ord('Z')+1)] + list("0123456789")
found = {}
for ch in wanted:
    fn = name_for(ch)
    path = os.path.join(svg_root, fn)
    if os.path.exists(path):
        found[ch] = path

if not found:
    raise RuntimeError("Nenhum SVG válido encontrado em /data ou nos ZIPs enviados.")

# Build a simple TTF
upm = 1000
fb = FontBuilder(upm, isTTF=True)
glyph_order = [".notdef"]
cmap = {}
advance = {}
glyphs = {}

def svg_to_glyph(svg_path):
    # parse paths from SVG; use picosvg parse_path for "d" commands
    # we accept the first 'd' path we find
    import xml.etree.ElementTree as ET
    tree = ET.parse(svg_path); root = tree.getroot()
    ns = {"svg": "http://www.w3.org/2000/svg"}
    # try any path
    d_attr = None
    for el in root.iter():
        if el.tag.endswith('path') and el.get('d'):
            d_attr = el.get('d'); break
    if not d_attr:
        raise RuntimeError(f"Sem <path d> em {svg_path}")
    # convert to quadratic with TTGlyphPen
    pen = TTGlyphPen(None)
    path = parse_path(d_attr)
    # path.segments gives line/quad/cubic; we approximate cubic as lines for simplicity if needed
    current = None
    for seg in path:
        cmd = seg.cmd
        pts = [Point(*p) for p in seg.points]
        if cmd == 'M':
            if current is not None:
                pen.endPath()
            pen.moveTo((pts[0].x, upm - pts[0].y))
            current = pts[0]
        elif cmd == 'L':
            pen.lineTo((pts[0].x, upm - pts[0].y))
            current = pts[0]
        elif cmd == 'Q':
            pen.qCurveTo((pts[0].x, upm - pts[0].y), (pts[1].x, upm - pts[1].y))
            current = pts[-1]
        elif cmd == 'C':
            # approximate cubic with two quads (very rough)
            a,b,c = pts
            pen.qCurveTo((a.x, upm-a.y), (b.x, upm-b.y))
            pen.qCurveTo((b.x, upm-b.y), (c.x, upm-c.y))
            current = pts[-1]
        elif cmd == 'Z':
            pen.closePath()
            current = None
    if current is not None:
        pen.endPath()
    glyph = pen.glyph()
    # set a default width
    return glyph, 1000

# build glyphs
for ch, path in found.items():
    gname = ch
    glyph, width = svg_to_glyph(path)
    glyph_order.append(gname)
    glyphs[gname] = glyph
    advance[gname] = (width, 0)
    cmap[ord(ch)] = gname

# required tables
fb.setupGlyphOrder(glyph_order)
fb.setupCharacterMap(cmap)
fb.setupGlyf(glyphs)
fb.setupHorizontalMetrics(advance)
fb.setupHorizontalHeader(ascent=800, descent=-200)
fb.setupOS2(sTypoAscender=800, sTypoDescender=-200, usWinAscent=800, usWinDescent=200)
fb.setupNameTable({"familyName":"KOBLLUX Symbols","styleName":"Regular","fullName":"KOBLLUX Symbols"})
fb.setupPost()

# save TTF
out_ttf = "/data/KOBLLUX-SYMBOLS.ttf"
fb.save(out_ttf)

print("OK: gravado", out_ttf)
`
    logln('Forjando… isso pode levar ~20–60s na primeira vez.');
    const res = await pyodide.runPythonAsync(code);
    logln(res || 'ok');
    // fetch the file back and trigger download
    const data = pyodide.FS.readFile('/data/KOBLLUX-SYMBOLS.ttf');
    const blob = new Blob([data], {type:'font/ttf'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'KOBLLUX-SYMBOLS.ttf';
    a.click();
    setTimeout(()=>URL.revokeObjectURL(a.href), 2000);
  }catch(err){
    console.error(err);
    logln('ERRO: ' + (err.message||err));
  }finally{
    runBtn.disabled = false;
  }
});
</script>
</body>
</html>
